package com.java.algorithm.hot100;

public class 不同路径_基础动规 {
    public static void main(String[] args) {
        /** 
         * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
         * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
         * 问总共有多少条不同的路径？
         * 
         * 输入：m = 3, n = 2
         * 输出：3
         * 解释：
         * 从左上角开始，总共有 3 条路径可以到达右下角。
         * 1. 向右 -> 向下 -> 向下
         * 2. 向下 -> 向下 -> 向右
         * 3. 向下 -> 向右 -> 向下
         */

         /**
          *思路：实际上看到m*n了，可以考虑动规划的情况，我们这里再复习一下动规的步骤
          */


         /** 
         * 大致动规的解题步骤：
         *  (1)确定dp数组（dp table）以及下标的含义
         *  (2)确定递推公式
         *  (3)确定数组如何初始化
         *  (4)确定递推顺序
         *  (5)举例推导
         * 一般画出二维数组图会更好理解
         */

         int n = uniquePaths(3, 2);
         System.out.println(n);



        
    }


    public static int uniquePaths(int m, int n) {
        //我们来看这个操作
        /**（1）下标含义直击题目，就是到达(i,j)位置的次数 */
        int[][] dp = new int[m][n];


        /**(2) 递推公式的话，以m=3，n=7为例，
        * dp[3][7] = dp[3][6] + dp[2][7]
        * 到达dp[3][7] 的可能性，等于到达dp[3][7]左边的所有可能性 + 到达dp[3][7]上边的所有可能性之和
        * 实际上到这里已经穷尽了可能，最后只是一个步骤而已
        * 所以递推公式可以是dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        */

        /**  (3)数组的初始化 
         * 初始次数都为0，
        */

        /*  (4)确认递推顺序
        // 递推顺序就是从左到右，从上到下
        // 因为这样的递推顺序，在思考初始化的问题，dp[0][0]这样情况应该算作只有一次
        */

        //先便利横向
        for(int i = 0; i < m ; i++){
            for(int j = 0 ;j < n ; j++){
                if(i== 0 || j ==0){
                    dp[i][j] =1;
                }else{
                    dp[i][j] = dp[i-1][j] + dp[j][j-1];
                }
            }
        }
        //算完之后返回右下角的治
        return dp[m-1][n-1];
    }
}

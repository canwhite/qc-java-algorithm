package com.java.algorithm.hot100;

import java.util.Arrays;

public class 最长有效括号_动规 {
    public static void main(String[] args) {
        /**
         * des:
         * 
         * 给你一个只包含 '(' 和 ')' 的字符串，
         * 找出最长有效（格式正确且连续）括号子串的长度。
         * 
         * 输入：s = "(()"
         * 输出：2
         * 解释：最长有效括号子串是 "()"
         * 
         * 
         * 输入：s = ")()())"
         * 输出：4
         * 解释：最长有效括号子串是 "()()" 
         * 
         */


         /** 
         * 大致动规的解题步骤：
         *  (1)确定dp数组（dp table）以及下标的含义
         *  (2)确定递推公式
         *  (3)确定数组如何初始化
         *  (4)确定递推顺序
         *  (5)举例推导
         */

        //最长问题好像还是使用动态规划比较好一点


        
        int n =  longestValidParentheses(")()())");
        System.out.println(n);



    }
    //先过一下背包问题
    public static int longestValidParentheses(String s) {

        //下标含义
        //dp[i]保持是以s[i]结尾的最长有效子串的长度。
        //将s转化为数组
        char[] ss = s.toCharArray();
        int length = ss.length;
        if(length == 0){
            return 0;
        }
        //初始化dp
        int[] dp = new int[length];
    

        //递归公式  
        /**实际上递推公式很多时候像是边界情况的考虑，
         * 明白了下标的含义，我们就可以基于此去分类讨论
         * p[i]保持是以s[i]结尾的最长有效子串的长度。
         **  顶层情况
         * 如果遇到s[i]是左括号，则以左括号结尾的最长有效子串一定是零，直接跳过；
         * 如果遇到s[i]是右括号，则需要根据s[i-1]的情况判断
         ** 然后开始讨论s[i-1]
         * 如果s[i-1]是左括号，说明s[i-1]和s[i]正好凑成一对儿，dp[i]直接在dp[i-2]的基础上加2即可
         * 如果s[i-1]是右括号，
         * 则需要寻找一下，与当前右括号s[i]配对的左括号应该在哪里，我们把这个左括号应该在的位置定义为j，有j = i - 1 - dp[i - 1]
         * 注意考虑的是位置，用的是下标
         * dp[i-1]即以s[i-1]结尾的有效括号的最大长度，相当于i位置和j位置的左右括号把dp[i-1]长度的有效子串夹在中间,是一段下标的长度
         * 然后再减去右侧括号
         * 就出现了一个可能是左括号的j
         ** 如果这个j是左括号
         * 则可以将以j-1结尾的最长有效子串，以i-1结尾的最长有效子串，
         * 以及i和j位置的左右括号一起合并成一个大的有效子串，长度一共是dp[j-1]+1+dp[i-1]+1，相当于把前边可能性也算上去了
         * 相反，如果j-1位置处不是左括号，说明当前右括号没有与之匹配的左括号，直接跳过次轮循环即可。
         * 
        */
        
        for (int i = 1; i < length; i++) {
            //如果s[i]是右括号
            if(ss[i] == ')'){
                //这时候再判断s[i-1]是不是左括号
                if(ss[i-1] == '('){
                    dp[i] = dp[i-2] + 2; //array可以这样直接赋值
                }else{
                    int j = i - 1 - dp[i - 1];
                    // dp[i] = dp[j-1] + dp[i-1] + 2;
                    if(j>=0  &&  ss[j] == '('){
                        dp[i] = dp[j - 1] + dp[i - 1] + 2;
                    }
                }
            }
        }
        //通过stream获取max值
        return Arrays.stream(dp).max().getAsInt();
    }




}

package com.java.algorithm.hot100;

public class 编辑距离 {
    public static void main(String[] args) {
        /**
         * 问题描述：
         * 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
         * 你可以对一个单词进行如下三种操作：
         * 插入、删除、替换字符
         * 
         */

         /**
            输入：word1 = "horse", word2 = "ros"
            输出：3
            解释：
            horse -> rorse (将 'h' 替换为 'r')
            rorse -> rose (删除 'r')
            rose -> ros (删除 'e')
          */


        /** 首先说下甜姨的思路，状态定义->状态转移，然后写出代码，
         * 这样实际上是carl五步的前两步，或者说是carl四步的前两步，
         * 再往后思考就是初始化和确认遍历顺序了
         * 最后有必要可以举例推导
        */
        /** 具体细节我们可以看carl的五步走 */
        /**
         *  ---------------------------------------------------------------------------------------
         * 
         * （1）确定dp数组以及下标含义（状态定义）
         * 
         *  dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。
         *  这里在强调一下：为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？
         *  用i来表示也可以！ 但我统一以下标i-1为结尾的字符串，在下面的递归公式中会容易理解一点。
         *  
         *  ---------------------------------------------------------------------------------------
         * 
         *  (2)确认递推公式（状态转移）
         * 
         *  if (word1[i - 1] == word2[j - 1]) {  不操作  }
         *  if (word1[i - 1] != word2[j - 1]) {  增 ｜ 删 ｜ 换}
         *  
         *  一共四种操作，其中删增可以看作一种，下边会讲
         * 
         *  a. 不操作的情况 为啥要即dp[i][j] = dp[i - 1][j - 1]呢？
         * 
         *      word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，
         *      以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的
         *      最近编辑距离dp[i - 1][j - 1]就是 dp[i][j]了
         * 
         *  b. 有增｜删｜换 -> if (word1[i - 1] != word2[j - 1])
         * 
         *  （b-1）操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。
         *      即 dp[i][j] = dp[i - 1][j] + 1;
         *  （b-2）操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。
         *      即 dp[i][j] = dp[i][j - 1] + 1;
         *   删和增实际上是一种操作，比如word1 = "doge", word2 = "dog",
         *   word1删除一个e，和word2增加一个e的达到的效果是一样的
         *   如果以数组实例来看的话，我们可以把它看作一个二维数组的转置
                **********************************************************************
                例如 word1 = "ad" ，word2 = "a"，word1删除元素'd' 和 word2添加一个元素'd'，
                变成word1="a", word2="ad"， 最终的操作数是一样！ dp数组如下图所示意的： 

                            a                         a     d
                +-----+-----+             +-----+-----+-----+
                |  0  |  1  |             |  0  |  1  |  2  |
                +-----+-----+   ===>      +-----+-----+-----+
                a |  1  |  0  |           a |  1  |  0  |  1  |
                +-----+-----+             +-----+-----+-----+
                d |  2  |  1  |
                +-----+-----+
                **********************************************************************
         *  （b-3）操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，
         *      那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。
         *   
         *   综上：当 if (word1[i - 1] != word2[j - 1]) 时取最小的，
         *        即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
         *   ---------------------------------------------------------------------------------------
         * 
         *  (3) dp数组如何初始化
         * 
         *  再回顾一下dp[i][j]的定义： 
         *  **dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。
         *  那么dp[i][0] 和 dp[0][j] 表示什么呢？
         *  dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。
         *  那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;
         *  同理dp[0][j] = j;     
         *  -------可以参照上边的删除去理解-------
         *  
         * 
         *  (4) 确认遍历顺序
         *  从上到下，从左到右
         * 
         * 
         * 
         */


        String word1 = "horse", word2 = "ros";
        int res = minDistance(word1, word2);
        System.out.println("---res---"+res);


    }
    public static int minDistance(String word1, String word2) {

        int len1 = word1.length(),len2 = word2.length();
        //初始化数组
        int[][] dp = new int[len1+1][len2+2];

        for(int i = 0; i<=len1; i++){
            dp[i][0] = i;
        }
        for(int j = 0; j <= len2; j++){
            dp[0][j] = j;
        }

        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                //若当前字母相同
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } 
                //增删改
                else {
                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);
                }
            }
        }
        return dp[len1][len2];
    }
    
}
